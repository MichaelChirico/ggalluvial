% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/alluvial-data.r
\name{alluvial-data}
\alias{alluvial-data}
\alias{is_lodes_form}
\alias{is_alluvia_form}
\alias{to_lodes_form}
\alias{to_alluvia_form}
\title{Test for alluvial structure and convert between alluvial formats}
\usage{
is_lodes_form(
  data,
  alluvia_from,
  axes_from,
  strata_from,
  y = NULL,
  weight = NULL,
  key,
  value,
  id,
  silent = FALSE
)

is_alluvia_form(data, axes = NULL, y = NULL, weight = NULL, silent = FALSE)

to_lodes_form(
  data,
  axes = NULL,
  y = NULL,
  weight = NULL,
  alluvia_to = "alluvium",
  axes_to = "x",
  axes_prefix = NULL,
  strata_to = "stratum",
  strata_drop_na = TRUE,
  y_to = "y",
  weight_to = "weight",
  key = NULL,
  value = NULL,
  id = NULL,
  diffuse = FALSE,
  discern = FALSE
)

to_alluvia_form(
  data,
  alluvia_from = "alluvium",
  axes_from = "axis",
  axes_prefix = "",
  axes_sep = "_",
  strata_from = "stratum",
  strata_fill = NULL,
  y = NULL,
  weight = NULL,
  key,
  value,
  id,
  distill = FALSE
)
}
\arguments{
\item{data}{A data frame.}

\item{alluvia_from, axes_from, strata_from}{Three arguments describing which
columns contain the alluvium (identifier), axis (key), and stratum (value)
of each row. These are analogous (and eventually passed) to
\verb{id_cols,names_from,values_from} in \code{\link[tidyr:pivot_wider]{tidyr::pivot_wider()}} and, as there,
handled using \code{\link[rlang:nse-defuse]{rlang::enquo()}}.}

\item{y, weight}{Optional column(s) containing alluvium heights (subject
magnitudes) and weights (used in computed variables).}

\item{key, value, id}{Deprecated aliases for \verb{axes_*,strata_*,alluvia_*},
respectively. While they still accept unquoted names, note that their
\verb{*_to} replacements only accept strings. If values are passed to both, then
these take precedence.}

\item{silent}{Whether to print explanatory messages.}

\item{axes}{An argument describing which columns contain the stratum (entry)
of each alluvium (row) at each axis (column). This is analogous (and
eventually passed) to \code{cols} in \code{\link[tidyr:pivot_longer]{tidyr::pivot_longer()}} and, as there,
handled using \code{\link[rlang:nse-defuse]{rlang::enquo()}}.}

\item{alluvia_to, axes_to, strata_to}{Three strings specifying the names of the
new columns to create for the alluvia (identifiers), axes (keys), and
strata (values). The latter two are analogous (and eventually passed) to
\verb{names_to,values_to} in \code{\link[tidyr:pivot_longer]{tidyr::pivot_longer()}}.}

\item{axes_prefix}{Passed to \code{names_prefix} in \code{\link[tidyr:pivot_longer]{tidyr::pivot_longer()}} or
\code{\link[tidyr:pivot_wider]{tidyr::pivot_wider()}}.}

\item{strata_drop_na}{Passed to \code{values_drop_na} in \code{\link[tidyr:pivot_longer]{tidyr::pivot_longer()}}.}

\item{y_to, weight_to}{Single strings specifying the names of the columns to
create from the column(s) identified by \code{y} or \code{weight}. If needed (for
multiple columns passed to \code{y} or to \code{weight}) but not provided, default
to \code{'y'} and \code{'weight'}, respectively.}

\item{diffuse}{Fields of \code{data} to merge into the lengthened data, joining by
\code{alluvia_to}. They must be among the variables passed to \code{axes}.
Alternatively, a logical value indicating whether to merge all (\code{TRUE}) or
none (\code{FALSE}) of these variables.}

\item{discern}{Logical value indicating whether to suffix values of the
variables passed to \code{axes} that appear at more than one axis, in order to
distinguish their factor levels. This forces the levels of the combined
factor variable \code{strata_to} to be in the order of the axes.}

\item{axes_sep}{Passed to \code{names_sep} in \code{\link[tidyr:pivot_wider]{tidyr::pivot_wider()}}.}

\item{strata_fill}{Passed to \code{values_fill} in \code{\link[tidyr:pivot_wider]{tidyr::pivot_wider()}}.}

\item{distill}{A logical value indicating whether variables excluded from
\code{axes_from} and \code{strata_from} that vary within values of \code{alluvia_from}
should be included in the result. Alternatively, a function (or its name)
to be used to distill each such variable to a single value. In addition to
existing functions, \code{distill} accepts the character values \code{"first"} (used
if \code{distill} is \code{TRUE}), \code{"last"}, and \code{"most"} (which returns the first
modal value).}
}
\description{
The functions \verb{is_*_form()} determine whether a data frame is alluvial---that
it has either the id--key--value structure of lodes format or the tidy
structure of alluvia format. The functions \verb{to_*_form()} convert data from
one format to the other.
}
\details{
Alluvial plots consist of multiple horizontally-distributed columns (axes)
representing categorical variables, vertical divisions (strata) of these axes
representing these variables' values; and ribbons (alluvial flows) connecting
vertical subdivisions (lodes) within strata of adjacent axes, representing
subsets or amounts of observations that take the corresponding values of the
corresponding variables. \strong{ggalluvial} can generate an alluvial plot from
data in either of two recognized formats:
\itemize{
\item \strong{Lodes format} encodes \emph{one row per measurement} or \emph{one row per lode},
using an id--key--value structure: Each row contains the recorded value of
one measurement (the key) for one subject or cohort (the id). Visually, the
lode is the unique intersection of one alluvium (the id) and one axis (the
key) and belongs to a unique stratum (the value). Additional columns may
contain lode-level variables, including magnitudes and weights.
\item \strong{Alluvia format} encodes \emph{one row per subject} or \emph{one row per alluvium},
using a \href{https://tidyr.tidyverse.org/}{tidy} structure: Each subject (or
cohort) has a row, each measurement has a column, and each measured value is
an entry. Additional columns may contain subject-level variables, including
magnitudes and weights; but lode-level magnitudes and weights may also be
encoded as column ranges having the same cardinality as those of the
measurements.
}

The functions \verb{is_*_form()} test for these structures. Both formats may
include missing values, by omission (lodes format) or as \code{NA}s (both). See
the primary vignette for several illustrations: \verb{vignette("ggalluvial)}.

The two formats are related by a specialized pair of pivot operations.
\code{to_lodes_form()} tests a data frame for alluvia format and then converts it
to lodes format; \code{to_alluvia_form()} does the reverse. Some information may
be lost under either operation, and the parameters \code{diffuse}, \code{discern}, and
\code{distill} give the user some control over how additional variables are
handled.
}
\examples{
# Titanic data in alluvia format
titanic_alluvia <- as.data.frame(Titanic)
head(titanic_alluvia)
is_alluvia_form(titanic_alluvia,
                y = "Freq")
# Titanic data in lodes format
titanic_lodes <- to_lodes_form(titanic_alluvia,
                               alluvia_to = "alluvium",
                               axes_to = "x",
                               strata_to = "stratum",
                               axes = c(Class, Age, Sex, Survived))
head(titanic_lodes)
is_lodes_form(titanic_lodes,
              alluvia_from = "alluvium",
              axes_from = "x",
              strata_from = "stratum",
              y = "Freq")
# again in lodes format, this time diffusing the `Class` variable
titanic_lodes2 <- to_lodes_form(titanic_alluvia,
                                alluvia_to = "passenger",
                                axes_to = "variable",
                                strata_to = "value",
                                axes = 1:3, diffuse = 1)
head(titanic_lodes2)
is_lodes_form(titanic_lodes2,
              alluvia_from = passenger,
              axes_from = variable,
              strata_from = value,
              y = Freq)
# once more in lodes format, this time specifying a `y` variable
titanic_lodes3 <- to_lodes_form(titanic_alluvia,
                                axes = 1:4,
                                alluvia_to = "passenger",
                                axes_to = "demographic",
                                strata_to = "value",
                                y = Freq,
                                y_to = "count")
head(titanic_lodes3)
is_lodes_form(titanic_lodes3,
              alluvia_from = passenger, axes_from = demographic,
              strata_from = value, y = count)

# curriculum data in lodes format
data(majors)
head(majors)
is_lodes_form(majors,
              alluvia_from = "student", axes_from = "semester",
              strata_from = "curriculum")
# curriculum data in alluvia format
majors_alluvia <- to_alluvia_form(majors,
                                  alluvia_from = "student",
                                  axes_from = "semester",
                                  strata_from = "curriculum")
head(majors_alluvia)
is_alluvia_form(majors_alluvia, tidyselect::starts_with("CURR"))

# distill variables that vary within `id` values
set.seed(1)
majors$hyp_grade <- LETTERS[sample(5, size = nrow(majors), replace = TRUE)]
majors_alluvia2 <- to_alluvia_form(majors,
                                   alluvia_from = "student",
                                   axes_from = "semester",
                                   strata_from = "curriculum",
                                   distill = "most")
head(majors_alluvia2)

# options to distinguish strata at different axes
gg <- ggplot(majors_alluvia,
             aes(axis1 = CURR1, axis2 = CURR7, axis3 = CURR13))
gg +
  geom_alluvium(aes(fill = as.factor(student)), width = 2/5, discern = TRUE) +
  geom_stratum(width = 2/5, discern = TRUE) +
  geom_text(stat = "stratum", discern = TRUE, aes(label = after_stat(stratum)))
gg +
  geom_alluvium(aes(fill = as.factor(student)), width = 2/5, discern = FALSE) +
  geom_stratum(width = 2/5, discern = FALSE) +
  geom_text(stat = "stratum", discern = FALSE, aes(label = after_stat(stratum)))
# warning when inappropriate
ggplot(majors[majors$semester \%in\% paste0("CURR", c(1, 7, 13)), ],
       aes(x = semester, stratum = curriculum, alluvium = student,
           label = curriculum)) +
  geom_alluvium(aes(fill = as.factor(student)), width = 2/5, discern = TRUE) +
  geom_stratum(width = 2/5, discern = TRUE) +
  geom_text(stat = "stratum", discern = TRUE)

# vaccination data in lodes format
data(vaccinations)
head(vaccinations)
is_lodes_form(vaccinations,
              alluvia_from = subject, axes_from = survey,
              strata_from = response, y = freq)
# vaccination data in alluvia format, with fixed `y`
head(to_alluvia_form(vaccinations,
                     alluvia_from = subject, axes_from = survey,
                     strata_from = response, y = freq))
# vaccination data in alluvial format, with variable `y`
set.seed(1)
vaccinations$perm <- sample(vaccinations$freq)
head(vaccinations)
head(to_alluvia_form(vaccinations,
                     alluvia_from = subject, axes_from = survey,
                     strata_from = response, y = perm,
                     distill = FALSE))

\dontrun{
# refugee data in lodes format
refugees <- alluvial::Refugees
head(refugees)
is_lodes_form(refugees,
              alluvia_from = country, axes_from = year, strata_from = country,
              y = refugees)
# refugee data in alluvial format, without `y` values
to_alluvia_form(refugees,
                axes_from = year, alluvia_from = country, strata_from = country)
# refugee data in alluvial format, with variable `y` values
to_alluvia_form(refugees,
                axes_from = year,
                alluvia_from = country,
                strata_from = country,
                y = refugees) ->
  refugees_alluvia
print(refugees_alluvia)
# back to lodes format
head(to_lodes_form(refugees_alluvia,
                   axes = `2003`:`2013`, y = starts_with("refugees_"),
                   alluvia_to = "id", axes_to = "year", strata_to = "origin",
                   y_to = "count"), n = 12)
}

# advanced conversion options
test_alluvia <- data.frame(
  id = LETTERS[seq(4L)],
  key1 = letters[sample(4L, replace = TRUE)],
  key2 = letters[sample(4L, replace = TRUE)],
  key3 = letters[sample(4L, replace = TRUE)],
  n1 = sample(6, 4L, replace = TRUE),
  n2 = sample(6L, 4L, replace = TRUE),
  n3 = sample(6L, 4L, replace = TRUE),
  wt1 = runif(4L, 0, 1),
  wt2 = runif(4L, 0, 1),
  wt3 = runif(4L, 0, 1)
)
# no heights or weights
to_lodes_form(test_alluvia,
              axes = starts_with("key"),
              alluvia_to = "alluv",
              axes_to = "instance", axes_prefix = "key",
              strata_to = "value")
# uniform heights
to_lodes_form(test_alluvia,
              axes = starts_with("key"), y = "n1",
              alluvia_to = "alluv",
              axes_to = "instance", axes_prefix = "key",
              strata_to = "value")
# variable heights
to_lodes_form(test_alluvia,
              axes = starts_with("key"), y = starts_with("n"),
              alluvia_to = "alluv",
              axes_to = "instance", axes_prefix = "key",
              strata_to = "value")
# variable heights with custom name
to_lodes_form(test_alluvia,
              axes = starts_with("key"),
              y = starts_with("n"),
              alluvia_to = "alluv",
              axes_to = "instance", axes_prefix = "key",
              strata_to = "value",
              y_to = "count")
# uniform heights and variable weights
to_lodes_form(test_alluvia,
              axes = starts_with("key"),
              y = "n2", weight = starts_with("wt"),
              alluvia_to = "alluv",
              axes_to = "instance", axes_prefix = "key",
              strata_to = "value",
              y_to = "count")
# variable heights and weights with custom names
to_lodes_form(test_alluvia,
              axes = starts_with("key"),
              y = starts_with("n"), weight = starts_with("wt"),
              alluvia_to = "alluv",
              axes_to = "instance", axes_prefix = "key",
              strata_to = "value",
              y_to = "count", weight_to = "contribution")
test_lodes <- .Last.value
# no heights or weights
to_alluvia_form(test_lodes,
                alluvia_from = id,
                axes_from = instance,
                strata_from = value)
# variable heights
to_alluvia_form(test_lodes,
                alluvia_from = id,
                axes_from = instance,
                strata_from = value,
                y = count)
# variable heights with distilled weights and prefixed axes
to_alluvia_form(test_lodes,
                alluvia_from = id,
                axes_from = instance,
                axes_prefix = "axis", axes_sep = "_for_",
                strata_from = value,
                y = count,
                distill = "mean")
# variable heights and weights
to_alluvia_form(test_lodes,
                alluvia_from = id,
                axes_from = instance,
                strata_from = value,
                y = count,
                weight = contribution)
# variable heights and wights with custom impution
test_lodes <- test_lodes[-sample(nrow(test_lodes), 2L), , drop = FALSE]
to_alluvia_form(test_lodes,
                alluvia_from = id,
                axes_from = instance,
                strata_from = value,
                strata_fill = list(count = 0L, contribution = 0),
                y = count,
                weight = contribution)
# un-factor stratum variable to use custom imputation
test_lodes$value <- as.character(test_lodes$value)
to_alluvia_form(test_lodes,
                alluvia_from = id,
                axes_from = instance,
                strata_from = value,
                strata_fill = list(value = "z", count = 0L, contribution = 0),
                y = count,
                weight = contribution)
}
\seealso{
Other alluvial data operations: 
\code{\link{self-adjoin}}
}
\concept{alluvial data operations}
