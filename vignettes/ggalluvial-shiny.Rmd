---
title: "ggalluvial in Shiny apps"
author: "Quentin D. Read"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{labeling small strata}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

## Problem

In an interactive visualization that incorporates an alluvial plot, it is visually cleaner and better for interpretation if labels and other information appear as "tooltips" when the user hovers over or clicks on elements of the plot. However, the `ggalluvial` package does not natively include this functionality. It is possible to enable this using functions from several other packages. This vignette illustrates a Shiny app that displays a ggalluvial plot with tooltips that appear when the user hovers over two different plot elements: strata created with `geom_stratum()` and alluvia created with `geom_alluvium()`. 

The tooltips that appear when the user hovers over elements of the plot show a text label and the number of flows included in each group. This is made relatively straightforward because if the user hovers or clicks somewhere inside a ggplot panel, Shiny automatically returns information about the location of the mouse cursor in plot coordinates. That means the main work we have to do is to extract or manually recalculate the coordinates of the different plot elements. With that information, we can determine which plot element the mouse is hovering over and display the appropriate information in the tooltip or other output method.

N.B.: The following code has several package dependencies; please be aware that all the required packages will need to be installed on the server where your Shiny app is running.

### Hovering over and clicking on strata

Enabling hovering over and clicking on strata is straightforward because of their rectangular shape. We only need the minimum and maximum `x` and `y` coordinates for each of the rectangles. The rectangles are evenly spaced along the x-axis, centered on each positive integer beginning with 1. The width is set with `geom_stratum` so for example we know that the x-coordinates of the first stratum are 1 &plusm; width/2. The y-coordinates can be determined from the number of rows in the input data multiplied by their weights.

### Hovering over and clicking on alluvia

Hovering over and clicking on alluvia are more difficult because the shapes of the alluvia are more complex. The default shape of the polygons includes an "xspline" curve drawn using the `grid` package. We need to manually reconstruct the coordinates of the polygons, then use `sp::pointInPolygon()` to detect which, if any, polygons the mouse is over.

## Data for reproducible example

This dummy dataset is used for the example app.

```{r dummy dataset}
library(ggalluvial)

example_data <- data.frame(weight = rep(1, 12),
                           ID = 1:12,
                           cluster = rep(c(1, 2), c(4, 8)),
                           grp1 = rep(c('1a', '1b', '1a', '1b'), c(3, 2, 3, 4)),
                           grp2 = rep(c('2a', '2b', '2a', '2b', '2a'), c(2, 2, 2, 2, 4)),
                           grp3 = rep(c('3a','3b', '3a', '3b'), c(3, 2, 2, 5)))
```

Here is a static plot generated using the dummy dataset.

```{r static plot}
ggplot(example_data, aes(y = weight, axis1 = grp1, axis2 = grp2, axis3 = grp3)) + 
  geom_alluvium(aes(fill = factor(cluster)), knot.pos = 0.25) + 
  geom_stratum(width = 1/8, reverse = TRUE) + # plot the boxes over the connections
  geom_text(aes(label = after_stat(stratum)), 
            stat = "stratum", 
            reverse = TRUE, 
            size = rel(3)) + 
  theme_bw() +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0))
```

## Structure of the app

### User interface

The example app demonstrated here includes a minimal user interface with two output elements.

```{r ui, eval = FALSE}
ui <- fluidPage(
  fluidRow(tags$div(
    style = "position: relative;",
    plotOutput("alluvial_plot", height = "800px", 
               hover = hoverOpts(id = "plot_hover")
               ),
    htmlOutput("tooltip")))
)
```

The elements are:

- a `plotOutput` with the argument `hover` defined, to enable behavior determined by the mouse's plot coordinates whenever the user hovers over or clicks on the plot.
- a `htmlOutput` for the tooltip that appears next to the mouse on hover.

Both of the elements are wrapped in a `fluidRow()` and a `div()` tag.

*Note*: This vignette only illustrates how to display output related to hovering. If you want to display output when the user clicks on an element, the corresponding argument to `plotOutput()` is `click = clickOpts(id = "plot_click")`. This will return the location of the mouse cursor in plot coordinates when the user clicks somewhere within the plot panel.

### Server function

The server function is more complex. Its general structure looks like this in pseudocode:

```{r server function skeleton}

server <- function(input, output, session) {
  
  output$alluvial_plot <- renderPlot({
    Create ggplot object for alluvial plot.
    
    Build alluvial plot.
    
    Extract data from built plot object that was used to create the alluvia polygons.
    
    Use the polygon splines to generate coordinates of the curved edges of the alluvia, in grid units.
    
    Convert the coordinates from grid units to data units. Assign this object globally.
    
    Render the plot.
  })
  
  output$tooltip <- renderText({
    if (mouse cursor is within the plot panel) {
      if (mouse cursor is within a stratum box) {
        Render stratum tooltip.
      } else {
        if (mouse cursor is within an alluvium polygon) {
          Render alluvium tooltip.
        }
      }
    }
  })
  
}

```


First, it creates the `ggplot` object for the alluvial plot, then we call the `ggplot_build` function to build the plot without displaying it. The next lines of code are to "reverse engineer" the polygon coordinates. Finally, we call `renderPlot` to pass the plot to `output`.

Next, we define the tooltip with a `renderText` expression. Within that expression, we first extract the mouse's plot coordinates from the user input. We first determine whether the mouse is hovering over a stratum and if so, display the appropriate tooltip. 

![screenshot of tooltip on stratum]()

If the mouse cursor is not hovering over a stratum, we determine whether it is hovering over an alluvium polygon and if so, display different information in the tooltip. 

![screenshot of tooltip on alluvium]()

If the mouse cursor is hovering over an empty region of the plot, nothing is returned by `renderText` and so no tooltip text box is displayed.

![screenshot of mouse over empty region]()

Let's take a deeper dive into each part of the server function.

#### 1. Drawing plot and extracting coordinates

```{r server part 1, eval = FALSE}
output$alluvial_plot <- renderPlot({
 
  # Width of node boxes
  node_width <<- 1/4
  
  p <- ggplot(example_data, aes(y = weight, axis1 = grp1, axis2 = grp2, axis3 = grp3)) + 
    geom_alluvium(aes(fill = factor(cluster)), knot.pos = 0.25) + 
    geom_stratum(width = node_width, reverse = TRUE) + # plot the boxes over the connections
    geom_text(aes(label = after_stat(stratum)), 
              stat = "stratum", 
              reverse = TRUE, 
              size = rel(3)) + 
    theme_bw() +
    scale_x_continuous(expand = c(0, 0)) +
    scale_y_continuous(expand = c(0, 0))
  
  # Build the plot. Use global assignment so that this object is accessible later.
  pbuilt <<- ggplot_build(p)
  
  # Use built plot data to recalculate the locations of the flow polygons.
  data_draw <- transform(pbuilt$data[[1]], width = 1/3)
  groups_to_draw <- split(data_draw, data_draw$group)
  group_coords <- lapply(groups_to_draw, draw_by_group) 
  
  # xspline coordinates
  xsplines <- lapply(group_coords, function(coords) grid::xsplineGrob(x=coords$x, y=coords$y, shape=coords$shape, open=FALSE))
  
  # Use grid::xsplinePoints to draw the curve for each polygon
  xspline_points <- lapply(xsplines, grid::xsplinePoints)
  
  # Define the x and y axis limits in grid coordinates (old) and plot coordinates (new)
  xrange_old <- range(unlist(lapply(xspline_points, function(pts) as.numeric(pts$x))))
  yrange_old <- range(unlist(lapply(xspline_points, function(pts) as.numeric(pts$y))))
  xrange_new <- c(1 - 1/6, 3 + 1/6) # From 1 to number of strata, adjusted by node width/2 (width always 1/3)
  yrange_new <- c(0, nrow(example_data)) 
  
  # Using the x and y limits, convert the grid coordinates into plot coordinates.
  # Use global assignment so that the object is accessible from within the following renderText expression.
  polygon_coords <<- lapply(xspline_points, function(pts) {
    x_trans <- new_range_transform(x_old = as.numeric(pts$x), range_old = xrange_old, range_new = xrange_new)
    y_trans <- new_range_transform(x_old = as.numeric(pts$y), range_old = yrange_old, range_new = yrange_new)
    list(x = x_trans, y = y_trans)
  })

  p # Return plot
}, 
res = 200)
```

#### 2. Logic for determining cursor location and displaying tooltips

```{r server part 2, eval = FALSE}
output$tooltip <- renderText(
  if(!is.null(input$plot_hover)) {
    hover <- input$plot_hover
    x_coord <- round(hover$x)
    
    if(abs(hover$x - x_coord) < (node_width / 2)) {
      # Display node information if mouse is over a stratum box.
      
      # Determine stratum name from x and y coord, and the n.
      node_row <- pbuilt$data[[2]]$x == x_coord & hover$y > pbuilt$data[[2]]$ymin & hover$y < pbuilt$data[[2]]$ymax
      node_label <- pbuilt$data[[2]]$stratum[node_row]
      node_n <- pbuilt$data[[2]]$n[node_row]
      renderTags(
        tags$div(
          node_label, tags$br(),
          "n =", node_n,
          style = paste0(
            "position: absolute; ",
            "top: ", hover$coords_css$y + offset, "px; ",
            "left: ", hover$coords_css$x + offset, "px; ",
            "background: gray; ",
            "padding: 3px; ",
            "color: white; "
          )
        )
      )$html
    } else {
      # Display flow information if mouse is over a flow polygon: what alluvia does it pass through?
      
      # Calculate whether coordinates of hovering mouse are inside one of the polygons.
      hover_within_flow <- sapply(polygon_coords, function(pol) point.in.polygon(point.x = hover$x, point.y = hover$y, pol.x = pol$x, pol.y = pol$y))
      if (any(hover_within_flow)) {
        # Find the alluvium that is plotted on top. (last)
        coord_id <- rev(which(hover_within_flow == 1))[1]
        # Get the corresponding row ID from the data.
        flow_id <- example_data$ID[coord_id]
        # Get the axis 1-3 values for all axes for that row ID.
        axis_values <- example_data[flow_id, c('grp1', 'grp2', 'grp3')]
        
        renderTags(
          tags$div(
            paste(axis_values, collapse = ' -> '),
            style = paste0(
              "position: absolute; ",
              "top: ", hover$coords_css$y + offset, "px; ",
              "left: ", hover$coords_css$x + offset, "px; ",
              "background: gray; ",
              "padding: 3px; ",
              "color: white; "
            )
          )
        )$html
      }
    }
  }
)
```


First, we check whether the cursor is over a stratum. We round the x-coordinate of the mouse cursor in data units to the nearest integer, then determine whether the x-coordinate is within `node_width / 2` of that integer. If so, the mouse cursor is horizontally within the box.

```{r}
hover <- input$plot_hover
x_coord <- round(hover$x)
    
if(abs(hover$x - x_coord) < (node_width / 2)) { ... }
```


The nearest integer to the y-coordinate corresponds to the row of the data frame because we set `reverse = TRUE` and all `weight = 1` in the input data. So for example the first row of the data frame corresponds to y range `c(0, 1)`, the second `c(1, 2)`, and so forth.

```{r}
node_row <- pbuilt$data[[2]]$x == x_coord & hover$y > pbuilt$data[[2]]$ymin & hover$y < pbuilt$data[[2]]$ymax
```


If the cursor is not over a stratum, the next logic checks whether it is over an alluvium. This is done using the function `sp::point.in.polygon` applied across each of the polygons for which we defined the coordinates inside the `renderPlot` expression.

```{r}
hover_within_flow <- sapply(polygon_coords, function(pol) point.in.polygon(point.x = hover$x, point.y = hover$y, pol.x = pol$x, pol.y = pol$y))
```


## Conclusion

This vignette demonstrates how to enable some fairly sophisticated features for `ggalluvial` plots in Shiny apps. However it's important to note that some of the workarounds are slightly inelegant. This may not be the optimal way to do it &mdash; other solutions are certainly possible!

## Appendix

### Complete app code

```{r full app, eval = FALSE}

```


### R session info

```{r session info}
sessioninfo::session_info()
```
